# [1045: SZTU Monthly 2023 May.](https://soj.csgrandeur.cn/csgoj/contest/problemset?cid=1045)

## List

#### [1045A-log2(N)](#a-log2n)

#### [1045B-迷宫](#b)

#### [1045C-不同路径](#c-不同路径)

#### [1045D-奶牛的逃亡](#d-奶牛的逃亡)

#### [1045E-最优对称路径](#e-最优对称路径压轴)

#### [1045F-过年](#f-过年)

---


### [A-log2(N)]()
考点：思维？
#### 题目大意
求 $ 2^{k} \leq N $ 最大的k；
#### 解题思路
卡了en久，不是很清楚为什么；但是我们如果发现要求满足某个条件的临界值，我们就让他越过条件，再往回找。

最后做出来的题目。

<strong>[code](A.cpp) </strong>

### [B-迷宫]()
考点：DFS
#### 题目大意
矩阵固定起点终点，搜多少不回头路径。
#### 解题思路
爆搜，每次走到终点就++

<strong>[code](B.cpp) </strong>

### [C-不同路径]()
考点：组合数
#### 题目大意
矩阵从左上角到右下角，只能向右向下；请问有多少种路径？
#### 解题思路
分配路径问题；不能回头，只能朝两个方向走。那就是固定步数行为，分配不同向右向下走的步子出现的时间顺序，就可以得到不同的路径。

想不到的一点是分配的是走的步数，不是长方形的边长；

<strong>[code](C.cpp) </strong>

回忆一下公式：
$$ C_{n}^{m}=C_{n-1}^{m}+C_{n-1}^{m-1} $$
题目里面给的数据小于25，可能考虑的是 ` 22!>LLONG_MAX `



### [D-奶牛的逃亡](http://poj.org/problem?id=3278)
考点：BFS
#### 题目大意
FJ可以左右移动一格，或者直接传送到自己坐标两倍的那个位置，求最少走到n的步数
#### 解题思路
就是求最少操作数，我们可以不断地去做这个三个动作，然后“在同样操作次数的情况下”看看哪种组合到了n，所以是BFS;

很搞笑的是这个题一点都不难，猛WA；原因最有可能的情况是在`x<<=1`的那个情况爆`INT`；

<strong>[code](D.cpp) </strong>

### [E-最优对称路径（压轴）]()
考点：单源最短路+DFS回溯
#### 题目大意
矩阵左上角走到右下角，要求路径关于副对角线对称，求最小的点权和

![图](https://soj.csgrandeur.cn/upload/problem_attach/2017-03-22_A786384210843CD3/best_symmetry_path.png)

#### 解题思路
分析题目，最奇怪的还是那个副对角线对称那个条件；如果说我们已经选出了一条到副对角线上的一条路径，我们仅仅通过每一个点的计算就可以得出另一个路径上的所有价值；再想到我们一定要达到右下角，一定要对称，那么我们计算每一个点的时候干脆就将对角线那边的点顺便加上。

$$ (x,y),(C-x,C-y)关于 y+x=C 对称 $$

接下来我把这个问题变成了从`(1,1)`到`x+y=n+1`这条线上的最短距离的重复个数，那记录历史最小值，然后相同的情况下更新个数；

一开始的硬搜T了，然后做出了一些改动：
1. 改变搜索顺序（把每次要搜的东西取出来，然后进行排序，再搜）
2. 记忆化，用该点dp历史记录来剪枝
3. 虽然不会IDEA*，但是还是yy了一种写法

照样t，猛t……

对于1来说，上次在用这个进行剪枝的时候就失败了，这次还是不行，这样贪心地去盲目搜索提供效果有限。记忆化，迭代加深搜索，都不熟悉，也不是到为什么t。

<strong>[code](E.cpp) </strong>

#### STD：
标准解答是用最短路写的，距离就是点权和，我们每次把新的点压栈，然后更新周围的点……这样就可以求出到不同点的、从`(1,1)`到那个点的单源最短路；
然后我们要求出有多少个这样的路径，我们试图找出这个路径的特征，那就是这个路径上的点之间的和的差值是等于前面那个点的的权值的，靠这个我们可以用DFS回溯，这个时候的回溯从`x+y=n+1`到`(1,1)`上面，变成了两个定点之间的满足路径的条数统计，变成了比赛的[<font color = prupe, size = 5> B 迷宫 </font>](#B)

<strong>[code](E_STD.cpp) </strong>

### [F-过年]()
考点：01背包
#### 题目大意
给一份钱可以拿固定多个数的商品，求最多拿多少商品
#### 解题思路
设 $dp[j]$ 为花那么多钱能拿到的最多的商品个数
$$ dp[j]=max_{i=1}^{n}{dp[j-p[i]]+min(c[i],k[i])} $$

套公式………………

<strong>[code](F.cpp) </strong>
